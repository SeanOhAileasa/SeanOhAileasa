<!----><div><h1>Introduction to Encoding, Serialization, XML, JSON, and YAML</h1>
<p>In this Learning Module, we will cover the following Learning Units:</p>
<ul>
<li>Introduction to Encoding and Data Serialization</li>
<li>XML Basics</li>
<li>JSON Basics</li>
<li>YAML Basics</li>
</ul>
<p><em>Serialization</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> is the process of converting data
(raw or formatted) into a portable and interoperable format. Converting
the serialized data back to how it was before that serialization
is referred to as <em>deserialization</em>. Any data can be serialized, even
serialized data. There is more than one type of serialization, but
serialization is often done so that the data can be used as a stream
of bytes sent from one system to another.</p>
<p>In this module, we will take the idea of serialization and apply
it to data serialization languages. Becoming proficient with
data serialization languages and formats takes time and practice,
especially given the complexity behind some formats and how different
applications may add rules of their own.</p>
<p>With that, we will not be able to completely cover them, but we
will get an overview of some common data formats and cover three
specific data serialization languages that are used in the industry:
<em>Extensible Markup Language</em> (XML), <em>JavaScript Object Notation</em>
(JSON), and <em>YAML Ain't Markup Language</em> (YAML).</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Serialization" target="_blank">https://en.wikipedia.org/wiki/Serialization</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div></section></div><!---->

<!----><div><h2>Introduction to Encoding and Data Serialization</h2>
<p>This Learning Unit covers the following Learning Objectives:</p>
<ol>
<li>Define and compare serialization vs serialization languages</li>
<li>Understand why data serialization is important</li>
<li>Compare and contrast XML, JSON, and YAML serialization languages</li>
</ol>
<p>In this Learning Unit, we will begin by getting a better understanding
of what serialization is and why it is important from a general
perspective. We will end by reviewing an overview of the three data
serialization languages before we expand on each of them within the
next Learning Units.</p>
</div><!---->

<h2>Encoding and Serialization</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p>Serialization is the process of converting data into a stream of bytes
between two or more different systems. For this module, we will focus
on converting things like an application state or data structures,
which brings us to data serialization languages. These languages
provide a format for serialization that can, in turn, be understood by
different platforms, applications, or architectures.</p>
<p>With varying data structures existing, a standardized format to
allow for the transfer of data or data structures more quickly and
easily was created by <em>Sun Microsystems</em>.<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> They
developed a data serialization format in the 1980s called <em>External
Data Representation</em> (XDR)<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> that encodes and decodes data
structures for transport.</p>
<p><em>Encoding</em><sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup> is conversion of data representation, a map
for expanding data into consistent portable data. The reverse
process is called <em>decoding</em>. When we encode data, we are typically
expanding the length by mapping data to a smaller set of characters.
The result is that data is typically larger when encoded.</p>
<p>There are numerous encoding standards, but some of the most
important examples to know are_Unicode_,<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup> <em>American
Standard Code for Information Interchange</em> (ASCII),<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup>
<em>base64</em>,<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup> and <em>hexadecimal</em>.<sup class="footnote-ref"><a href="#fn7" id="fnref7">7</a></sup> Unicode is the
larger of the encoding types, having over one million different
characters and spots for many more in the future. Unicode has three
encoding specifications as subsets of the Unicode specification:
UTF-32,<sup class="footnote-ref"><a href="#fn8" id="fnref8">8</a></sup> UTF-16,<sup class="footnote-ref"><a href="#fn9" id="fnref9">9</a></sup> and UTF-8.<sup class="footnote-ref"><a href="#fn10" id="fnref10">10</a></sup> The 32
in UTF-32 means 32 bits are used to represent a given UTF-32 character
as an integer. UTF-16 and UTF-8 are slightly more complex because bits
used can vary depending on the character.</p>
<p>Here is an example of some UTF-8 characters along with their Unicode
<em>codepoint</em><sup class="footnote-ref"><a href="#fn11" id="fnref11">11</a></sup> values and binary representation.</p>
<table>
<thead>
<tr>
<th>UTF-8 Character</th>
<th>UTF-8 codepoint</th>
<th>binary</th>
</tr>
</thead>
<tbody>
<tr>
<td>(thin space)</td>
<td>U+2009</td>
<td>100000 00001001</td>
</tr>
<tr>
<td>✨</td>
<td>U+2728</td>
<td>11100010 10011100 10101000</td>
</tr>
<tr>
<td>3</td>
<td>U+0033</td>
<td>110011</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Table 1 - unicode examples</p>
</blockquote>
<p>The example "thin space" can't be shown in our table as UTF-8, as
it is an invisible character. There are many invisible characters
possible, including control characters that execute special machine
instructions like <em>delete</em>. In order to avoid these invisible
characters getting lost, executing special instructions, or otherwise
causing problems for applications, we can use hex or base64 encoding
to move them around safely.</p>
<table>
<thead>
<tr>
<th>UTF-8 Character</th>
<th>hex encoded</th>
<th>base64 encoded</th>
</tr>
</thead>
<tbody>
<tr>
<td>(thin space)</td>
<td>e28089</td>
<td>4oCJ</td>
</tr>
<tr>
<td>✨</td>
<td>e29ca8</td>
<td>84pyo</td>
</tr>
<tr>
<td>3</td>
<td>33</td>
<td>Mw==</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Table 2 - unicode examples as hex and base64</p>
</blockquote>
<p>Unlike the enormousness and complexity of Unicode, ASCII is a much
smaller set of characters, commonly broken into two groups. The
first group of characters is the 0-127 group, or the standard ASCII
characters. This group includes some control characters such as
<em>delete</em>, <em>shift</em>, and even the beep noise known as <em>bell</em>, along with
others. This first group is roughly the same characters we can get
from a standard keyboard. The second group of ASCII characters is the
<em>extended ASCII</em> group, 128-255, which primarily include additional
symbols and shapes.</p>
<p>Base64 is 64 characters, although it is worth noting there are
different types of base64 encoding with slight variations. Most base64
versions include only visible characters, although it is possible to
use a non-standard base64 set that includes invisible characters. Most
commonly the base64 sets used are <em>canonical base64</em>, the same as we
get from the base64 program in Linux, and <em>web-safe base64</em>, which is
used for web programming. The main differences between the two is that
the forward slash in common base64 is replaced with an underscore in
web-safe base64, and the plus sign in common base64 is replaced with a
hyphen in web-safe base64. These changes for web-safe base64 are there
to align with JSON format specifications, which we will discuss later
in this module. There are also base32 and base16 encodings, and hex is
a type of base16.</p>
<section class="sb-block"><p>The equals signs in base64 are padding, and can be disregarded and
the decoding will still work.</p></section>
<p>The smaller the character set, the larger the encoding conversion will
increase the data size. Base64 encoding typically increases the data
size by about 33%.</p>
<p>Hex is the smallest set we will use, with only 16 characters, 0-9
and a-f. There are only two variations of hex: hex uppercase and hex
lowercase. Because hex (hexadecimal) is the smallest set we will use,
it often makes the largest data sizes. The benefit however is that hex
is the most portable and interoperable of the types we have discussed.
Hex encoded data can go pretty much anywhere.</p>
<section class="sb-block"><p>Encoding is not encryption, it does not provide secrecy for
the data. Encoding is used for portability and display. Encryption
might utilize encoding, but encoding by itself does not really make
something secret. Base64 encoding data makes it easier to move around
and view, but does not provide encryption itself.</p></section>
<p>While encoding does not provide secrecy, it can be used to aid in
malicious activity. If an organization has a binary program that
is an internal secret that should not leave the servers, but the
servers allow DNS out to the internet, an internal malicious
actor that has access to the server might be able to perform <em>data
exfiltration</em><sup class="footnote-ref"><a href="#fn12" id="fnref12">12</a></sup> by encoding the binary to a more
portable format, then sending that portable text representation out to
a malicious DNS server or copy and pasting the hex out of the terminal
to another location.</p>
<p>Here is an example of encoding and decoding binary to hex with
<em>xxd</em>.<sup class="footnote-ref"><a href="#fn13" id="fnref13">13</a></sup> We will encode the entire binary for <em>bash</em>
into hex as an example. We are not displaying all of the encoded
data in the example as it a large amount of output, and we are only
decoding the first part of the hex.</p>
<p>Data can be piped into the <em>xxd</em> and <em>base64</em> programs for encoding
or decoding. The <strong>-p</strong> option tells xxd to use plain hex encoding
of the input, while <strong>-r</strong> combined with <strong>-p</strong> decodes plain hex.
When we echo the data we use <strong>-n</strong> in the example to avoid including
a newline character in the input, and we pipe the <strong>echo</strong> data into
<strong>xxd</strong>.</p>
<pre id="fence-code-81" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">xxd -p /bin/bash</span>
7f454c4602010100000000000000000003003e0001000000700603000000
0000400000000000000098be12000000000000000000400038000d004000
1e001d000600000004000000400000000000000040000000000000004000
000000000000d802000000000000d8020000000000000800000000000000
030000000400000018030000000000001803000000000000180300000000
00001c000000000000001c00000000000000010000000000000001000000
04000000000000000000000000000000000000000000000000000000f0de
020000000000f0de02000000000000100000000000000100000005000000
00e002000000000000e002000000000000e0020000000000ada20b000000
0000ada20b00000000000010000000000000010000000400000000900e00
0000000000900e000000000000900e0000000000c86f030000000000c86f
03000000000000100000000000000100000006000000d002120000000000
d012120000000000d01212000000000074ba000000000000c86a01000000
000000100000000000000200000006000000f02c120000000000f03c1200
00000000f03c120000000000000200000000000000020000000000000800
000000000000040000000400000038030000000000003803000000000000
380300000000000020000000000000002000000000000000080000000000
000004000000040000005803000000000000580300000000000058030000
0000000044000000000000004400000000000000040000000000000053e5
...

kali@kali:~$ <span class="code-block-ui">echo -n 7f454c46 | xxd -r -p</span>
ELF
</code></pre>
<blockquote>
<p>Listing 1 - xxd hex example</p>
</blockquote>
<p>We can do a similar operation with base64. In our example with the
<strong>base64</strong> program, we will use no options on the encoding and the
<strong>-d</strong> option on the decoding.</p>
<pre id="fence-code-82" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">base64 /bin/ls</span>
f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAgGEAAAAAAABAAAAAAAAAAGg3AgAAAAAAAAAAAEAAOAAL
AEAAHgAdAAYAAAAEAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAaAIAAAAAAABoAgAAAAAAAAgA
AAAAAAAAAwAAAAQAAACoAgAAAAAAAKgCAAAAAAAAqAIAAAAAAAAcAAAAAAAAABwAAAAAAAAAAQAA
AAAAAAABAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg1AAAAAAAAODUAAAAAAAAAEAAA
AAAAAAEAAAAFAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAyUMBAAAAAADJQwEAAAAAAAAQAAAA
AAAAAQAAAAQAAAAAkAEAAAAAAACQAQAAAAAAAJABAAAAAAC4igAAAAAAALiKAAAAAAAAABAAAAAA
AAABAAAABgAAAFAjAgAAAAAAUDMCAAAAAABQMwIAAAAAAHgSAAAAAAAAaCUAAAAAAAAAEAAAAAAA
AAIAAAAGAAAA2C0CAAAAAADYPQIAAAAAANg9AgAAAAAA8AEAAAAAAADwAQAAAAAAAAgAAAAAAAAA
BAAAAAQAAADEAgAAAAAAAMQCAAAAAAAAxAIAAAAAAABEAAAAAAAAAEQAAAAAAAAABAAAAAAAAABQ
5XRkBAAAAAzfAQAAAAAADN8BAAAAAAAM3wEAAAAAAEQJAAAAAAAARAkAAAAAAAAEAAAAAAAAAFHl
dGQGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAUuV0
ZAQAAABQIwIAAAAAAFAzAgAAAAAAUDMCAAAAAACwDAAAAAAAALAMAAAAAAAAAQAAAAAAAAAvbGli
NjQvbGQtbGludXgteDg2LTY0LnNvLjIABAAAABQAAAADAAAAR05VAG49pvC8NrY5i4ZRu8LgiDGi
GpDaBAAAABAAAAABAAAAR05VAAAAAAADAAAAAgAAAAAAAAARAAAAbgAAAAIAAAAHAAAApqFIBBIB
rjYg2BESIAAAkG4AAAAAAAAAbwAAAHAAAAByAAAAcwAAAHQAAAB2AAAAdwAAAAAAAAB5AAAAewAA
AHwAAAAAAAAAfQAAAH4AAAB/AAAAvVB2njPE9xKG8JZ8l6CJl88sY3KTmDyttvoB60+O/X858osc
TD6lC+ViQfUCPn9bs6L3En9qmnXRZc5tjcfgYD2tOQ0pHYwcAAAAAAAAAAAAAAAAAAAAAAAAAAAA
...

kali@kali:~$ <span class="code-block-ui">echo -n f0VMRgIB | base64 -d</span>
ELF
</code></pre>
<blockquote>
<p>Listing 2 - base64 example</p>
</blockquote>
<p>If we want to have serialized hex or base64, we might pipe the output
to the <em>tr</em><sup class="footnote-ref"><a href="#fn14" id="fnref14">14</a></sup> program to remove line breaks and have the
output all be a single stream of bytes without interruption. Removing
newlines is perhaps the most generic "serialization", literally
meaning one byte after the next in a continuous stream. We will use
the <strong>-d</strong> option for <strong>tr</strong> to delete, passing <strong>'\n'</strong> to delete
newline characters.</p>
<pre id="fence-code-83" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">xxd -p /bin/bash | tr -d '\n'</span>
7f454c4602010100000000000000000003003e00010000007006030000000000400000000000000098be12000000000000000000400038000d0040001e001d000600000004000000400000000000000040000000000000004000000000000000d802000000000000d802000000000000080000000000000003000000040000001803000000000000180300000000000018030000000000001c000000000000001c0000000000000001000000000000000100000004000000000000000000000000000000000000000000000000000000f0de020000000000f0de0200000000000010000000000000010000000500000000e002000000000000e0
...
</code></pre>
<blockquote>
<p>Listing 3 - serialized hex example</p>
</blockquote>
<p>The base64 and xxd programs know to ignore those newlines, so the data
will be correctly re-assembled during decoding even if extra newlines
are added to the encoded form. However, there are some situations
where we want to have serialized encoded data with no added newline
characters and so we serialize the data into a single line.</p>
<p>Encoding and serializing is great for moving data around and viewing
the data on computer displays and paper, but they don't solve all
of our problems. There is a desire for even more standardization of
data. Data serialization languages provide the structure and standards
around the data so that different applications can program, load, and
export the data in ways that other programs can utilize the same data
structures. Data serialization languages reduce the need to provide
additional instruction or requirements regarding the data structures
themselves. We call this property that improves use between different
systems <em>interoperability</em>.</p>
<p>Data serialization languages do much more than remove line breaks.
Instead, they standardize the structure of the data by providing rules
for encoding, labeling, and mapping of the data. The data serialized
into JSON, is formatted in a valid JSON structure. This type of
serialization can also allow the data to be streamed, stored, and
otherwise shared between different computer systems and applications
while maintaining generic properties in the data structures.</p>
<p>Imagine if we didn't have data serialization languages, and each
programmer made their own data formats. Sure we could use serialized
hex to send it between different systems easily, but we would also
have to provide instructions to each other programmer that needed to
digest the data after being deserialized, explaining what the format
is and how to load it into their programs. The result is endless
different formats and much more time required to integrate different
applications together. Data serialization languages include data
format standards that help reduce the amount of application-specific
structures. Data serialization languages don't eliminate the need for
documentation or explanation entirely, but allow the documentation
to focus on the application features rather than the data structures
format specifications.</p>
<p>Now that we have a better understanding of encoding and why
serialization languages are important, let's compare three specific
types: XML, JSON, and YAML.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Sun_Microsystems" target="_blank">https://en.wikipedia.org/wiki/Sun_Microsystems</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/External_Data_Representation" target="_blank">https://en.wikipedia.org/wiki/External_Data_Representation</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn3"><sup>3</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Character_encoding" target="_blank">https://en.wikipedia.org/wiki/Character_encoding</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn4"><sup>4</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Unicode" target="_blank">https://en.wikipedia.org/wiki/Unicode</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn5"><sup>5</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/ASCII" target="_blank">https://en.wikipedia.org/wiki/ASCII</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn6"><sup>6</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Base64" target="_blank">https://en.wikipedia.org/wiki/Base64</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn7"><sup>7</sup><p>(IETF, 2006), <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-8" target="_blank">https://datatracker.ietf.org/doc/html/rfc4648#section-8</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn8"><sup>8</sup><p>(Unicode Inc.), <a href="https://www.unicode.org/L2/L1999/99172.htm" target="_blank">https://www.unicode.org/L2/L1999/99172.htm</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn9"><sup>9</sup><p>(Unicode Inc.), <a href="https://www.unicode.org/faq/utf_bom.html" target="_blank">https://www.unicode.org/faq/utf_bom.html</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn10"><sup>10</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank">https://en.wikipedia.org/wiki/UTF-8</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn11"><sup>11</sup><p>(IETF, 2010), <a href="https://tools.ietf.org/search/rfc5892" target="_blank">https://tools.ietf.org/search/rfc5892</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn12"><sup>12</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Data_exfiltration" target="_blank">https://en.wikipedia.org/wiki/Data_exfiltration</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn13"><sup>13</sup><p>(Linux man page, 2022), <a href="https://linux.die.net/man/1/xxd" target="_blank">https://linux.die.net/man/1/xxd</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn14"><sup>14</sup><p>(man7.org, 2021), <a href="https://www.man7.org/linux/man-pages/man1/tr.1.html" target="_blank">https://www.man7.org/linux/man-pages/man1/tr.1.html</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>

<h2>XML, JSON, and YAML</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p>A similarity of all three serialization languages is the fact that they
are all open formats, which means that they are non-proprietary, and
can be freely used by anyone.</p>
<p>Another small similarity is the common file extensions, which are
the same as the acronym. An XML file uses <strong>.xml</strong>, while a JSON
file uses <strong>.json</strong>, and a YAML file uses <strong>.yaml</strong> (or <strong>.yml</strong>).
File extensions are often optional in Unix-based systems, although
typically a good idea to use anyway.</p>
<p>Another important fact is that YAML is a superset of JSON, meaning
all JSON is considered valid YAML. JSON is a fairly linear format,
while YAML is complex and can include many different types of data,
including JSON.</p>
<p>In terms of differences, there are a few factors to mention.</p>
<p>First is the human readable formatting. One of the main reasons
they were created was to represent the data or information in a
consistent readable format. Generally, YAML files are considered a
more human-readable format when compared to JSON or XML, but this may
not always be the case (some people prefer reading JSON to YAML for
example). And while YAML may seem simple, the reality of YAML and XML
is that they are complex. We won't be covering all of the complexities
of YAML and XML in this module, but let's review an example of each to
get a better understanding.</p>
<p>We'll start with XML.</p>
<pre id="fence-code-84" class="fence-code"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;CarsInStock&gt;
&lt;Car id="Car1"&gt;
&lt;model&gt;Ford&lt;/model&gt;
&lt;make&gt;Focus&lt;/make&gt;
&lt;color&gt;Blue&lt;/color&gt;
&lt;/Car&gt;

&lt;Car id="Car2"&gt;
&lt;model&gt;Ford&lt;/model&gt;
&lt;make&gt;F-150&lt;/make&gt;
&lt;color&gt;Black&lt;/color&gt;
&lt;/Car&gt;

&lt;/CarsInStock&gt;
</code></pre>
<blockquote>
<p>Listing 4 - XML Example</p>
</blockquote>
<p>In general, the data is presented in a way that is difficult to
identify the element text or values. Let's compare that to a JSON
example.</p>
<pre id="fence-code-85" class="fence-code"><code>{
"CarsInStock": {
"Car": [
{
"id":"Car1",
"model":"Ford",
"make":"Focus",
"color":"Blue"
},
{
"id":"Car2",
"model":"Ford",
"make":"F-150",
"color":"Black"
}
]
}
}
</code></pre>
<blockquote>
<p>Listing 5 - JSON Example</p>
</blockquote>
<p>Without all the tags in XML, JSON is a bit easier to quickly read
through and identify the element text. Lastly, we'll review a YAML
example.</p>
<pre id="fence-code-86" class="fence-code"><code># Cars In Stock

- Car 1:
    model: Ford
    make: Focus
    color: Blue

- Car 2:
    model: Ford
    make: F-150
    color: Black
</code></pre>
<blockquote>
<p>Listing 6 - YAML Example</p>
</blockquote>
<p>While we <em>can</em> indent XML and JSON, most YAML requires some
indentation. The number of spaces used in YAML indentation isn't
a fixed set of spaces in the YAML specification, but it does have
to exist for certain YAML data styles. We will expand more on the
indentation rules within YAML in the YAML section of this module.</p>
<p>The application use of the data will typically determine which
serialization languages are used. If we have a web application using
JavaScript, it might make the most sense to use JSON. In comparison,
if we need to program for <em>SAML 2.0</em>,<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> XML is used.</p>
<p>There are other options out there and Wikipedia has a comparison
table outlining <em>data serialization formats</em>.<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>
XML, JSON, and YAML are some of the most well-known ones, but there
may be a situation where it makes sense to use a completely different
format.</p>
<p>In this Learning Unit, we've learned a little about encoding,
serialization, and serialization languages, and why they are important
in modern computing. We also compared XML, JSON, and YAML.</p>
<p>In the next three Learning Units, we will get a stronger understanding
of the syntax for each of the three formats. We will start with XML.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(IETF, 2018), <a href="https://datatracker.ietf.org/doc/html/rfc8409" target="_blank">https://datatracker.ietf.org/doc/html/rfc8409</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats" target="_blank">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>

<!----><div><h2>XML Basics</h2>
<p>This Learning Unit covers the following Learning Objectives:</p>
<ol>
<li>Understand XML syntax</li>
</ol>
<p>In this Learning Unit, we will learn more about <em>Extensible Markup
Language</em> (XML)<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> including basic syntax.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/XML" target="_blank">https://en.wikipedia.org/wiki/XML</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div></section></div><!---->

<h2>XML Introduction</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p>XML was created from <em>Standard Generalized Markup Language</em>
(SGML)<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> in 1996, initialally published in 1997, with larger
adoption starting in 1998. Most of the structures from XML come
directly from SGML. <em>HyperText Markup Language</em> (HTML)<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> was
developed before XML during the same time as SGML. A simplified way to
think about SGML is that it is more vague of a standard than both HTML
and XML were created from.</p>
<p>HTML is more commonly used for display in web browsers, while XML
is more commonly used in system to system communication but can
also be used for interfaces and web pages. <em>Cascading Style Sheets</em>
(CSS)<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup> transform HTML, while <em>Extensible Stylesheet Language
Transformations</em> (XSLT)<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup> is used to make transformations
on XML. There are also many more ways that XML can be transformed and
integrated, but we will not be covering those specifications in this
module. Now that we have a better understanding of how XML can be
used, let's learn the syntax.</p>
<p>XML allows a subset of Unicode with strict rules. As we will
explore later on in the module, data that doesn't fit into the
data serialization format may need to be additionally encoded
to hex or base64 before being inserted. The only Unicode control
characters<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup> allowed in XML 1.0 data are
carriage return (+000D), end of line (U+000A), and tab (U+0009).</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(IETF, 1995), <a href="https://www.rfc-editor.org/rfc/rfc1874" target="_blank">https://www.rfc-editor.org/rfc/rfc1874</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/HTML" target="_blank">https://en.wikipedia.org/wiki/HTML</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn3"><sup>3</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/CSS" target="_blank">https://en.wikipedia.org/wiki/CSS</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn4"><sup>4</sup><p>(w3c, 2017), <a href="https://www.w3.org/TR/xslt-30/" target="_blank">https://www.w3.org/TR/xslt-30/</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn5"><sup>5</sup><p>(Unicode Inc.), <a href="https://www.unicode.org/versions/Unicode14.0.0/" target="_blank">https://www.unicode.org/versions/Unicode14.0.0/</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>

<h2>XML Syntax</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p>In this section, we will review the syntax associated with XML files.
As we move along, we will create an XML file.</p>
<p>Although not always required, an XML file starts with a statement
called a <em>prolog</em>.<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> The prolog is enclosed using
<em>processing instruction</em> (PI)<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> symbols,
represented by the less-than sign, question marks, and greater-than
signs (&lt;? ?&gt;). This provides instructions to the application. Within
the PIs, we will generally find the target and additional optional
content. In this case, the target is "xml", which is also referred
to as the <em>XML Declaration</em>.<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup> The usual content
within the PI specifies the version and character encoding.</p>
<p>There are multiple versions of the XML specification. We will use
XML 1.0 in our examples for this module, but there is also the XML
1.1 specification that includes different encoding rules and more. We
won't be doing a breakdown of XML 1.0 vs XML 1.1 in this module, but
for the remainder of the module, we will use version 1.0. The Unicode
encoding format we will use in the example is UTF-8.</p>
<p>Let's create an XML file by starting the with prolog statement:</p>
<pre id="fence-code-88" class="fence-code"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</code></pre>
<blockquote>
<p>Listing 7 - XML Prolog</p>
</blockquote>
<p>As expected, the prolog statement begins with an opening PI symbol of
"&lt;?", followed by the XML declaration. Then, it specifies the version
of 1.0 and encoding format of UTF-8 as a name-value pair, before
closing the statement using the PI symbol of "?&gt;".</p>
<p>Following the prolog statement are structures called elements, which
are organized in a structure. The top of the structure is referred
to as the <em>root element</em>, which is followed by <em>child elements</em>. At a
minimum, an XML file has to include one root element. All elements are
enclosed within tags and are case-sensitive.</p>
<p>Let's take the prolog statement from above and add a root element.</p>
<pre id="fence-code-89" class="fence-code"><code>1  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
2  <span class="code-block-p">&lt;CarsInStock&gt;</span>
3
4  <span class="code-block-p">&lt;/CarsInStock&gt;</span>
</code></pre>
<blockquote>
<p>Listing 8 - Add a root element</p>
</blockquote>
<p>Line 2 has a root element start tag called <em>CarsInStock</em>, while line
4 has a root element end tag. The difference is the forward slash
before the name of the tag. Except for of the prolog statement (line
1), all elements must have start and end tags.</p>
<p>Although not mandatory, elements can contain attributes in a
name-value pair, text, other elements (nested), or any of them
combined.</p>
<p>Let's add some nested elements to our XML file.</p>
<pre id="fence-code-90" class="fence-code"><code>1  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
2  &lt;CarsInStock&gt;
3    <span class="code-block-p">&lt;Car id="Car1"&gt;</span>
4    <span class="code-block-p">&lt;/Car&gt;</span>
5    <span class="code-block-s">&lt;Car id="Car2"&gt;</span>
6    <span class="code-block-s">&lt;/Car&gt;</span>
7  &lt;/CarsInStock&gt;
</code></pre>
<blockquote>
<p>Listing 9 - Add nested elements</p>
</blockquote>
<p>On lines 3 through 6, we've added two elements named <em>Car</em>
that are nested within the root elements of <em>CarsInStock</em>. Both
<em>Car</em> elements have an attribute named <em>id</em> with their own unique
values. Another concept to point out is something called a <em>first-in,
last-out</em> aspect associated with start and end tags. The <em>Car</em>
elements were created last within the <em>CarsInStock</em> elements.
Therefore, their end tags must be present first. Whichever element was
created first, that element will have an end tag last.</p>
<p>Let's compare the previous example with the following incorrect
example:</p>
<pre id="fence-code-91" class="fence-code"><code>1  <span class="code-block-p">&lt;CarsInStock&gt;</span>
2    <span class="code-block-s">&lt;Car id="Car1"&gt;</span>
3  <span class="code-block-p">&lt;/CarsInStock&gt;</span>
4    <span class="code-block-s">&lt;/Car&gt;</span>
</code></pre>
<blockquote>
<p>Listing 10 - Incorrect nested elements</p>
</blockquote>
<p>The <em>CarsInStock</em> element start tag (line 1) exists before the <em>Car</em>
element start tag (line 2). Above, the <em>CarsInStock</em> element end tag
(line 3) appears before the <em>Car</em> element end tag (line 4). This will
cause a syntax error, because the first in, last out concept is not
followed.</p>
<p>Here is the correct way to order the above example:</p>
<pre id="fence-code-92" class="fence-code"><code>1  <span class="code-block-p">&lt;CarsInStock&gt;</span>
2    <span class="code-block-s">&lt;Car id="Car1"&gt;</span>
3    <span class="code-block-s">&lt;/Car&gt;</span>
4  <span class="code-block-p">&lt;/CarsInStock&gt;</span>
</code></pre>
<blockquote>
<p>Listing 11 - Correct nested elements</p>
</blockquote>
<p>The <em>Car</em> element end tag (line 3) is before the <em>CarsInStock</em> element
end tag (line 4), because the <em>Car</em> element start tag (line 2) is
after the <em>CarsInStock</em> start tag (line 1). Therefore, the first
element in, last element out concept is correctly followed.</p>
<p>XML element names have certain standards or <em>naming
conventions</em><sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup> that must be adhered to. For
example, they must begin with a letter or underscore, and cannot start
with the keyword, "xml". XML element names are case-sensitive, and
must not contain spaces. Numbers and certain special characters, like
hyphens and periods, can be used as part of the name.</p>
<p>Another tip to keep in mind is what other software XML will
communicate with, if any. Depending on the situation, it may be best
to avoid using special characters. As an example, some programming
languages use a period (.) to refer to a property or component.
Although periods are technically allowed, there may be situations
where the functionality may break due to how some programming
languages treat periods.</p>
<p>Let's review a few examples of correct naming conventions.</p>
<pre id="fence-code-93" class="fence-code"><code>&lt;car&gt;
&lt;Car&gt;
&lt;car1&gt;
&lt;myCar&gt;
&lt;my.car&gt;
&lt;my_car&gt;
&lt;my-first-car1&gt;
&lt;myCar_withXML&gt;
</code></pre>
<blockquote>
<p>Listing 12 - Allowed naming convention examples</p>
</blockquote>
<p>The last element name is allowed because it does not begin with the
letters "xml".</p>
<p>Now let's compare the allowed naming convention examples with a few
examples that are not allowed by XML, which will be highlighted in
red. We will also include <em>comments</em>,<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup> highlighted in
green, next to the element that explains which rule it breaks. As an
aside, syntax for comments is: <em>&lt;!-- My Comment --&gt;</em>.</p>
<pre id="fence-code-94" class="fence-code"><code>&lt;<span class="code-block-p">xml</span>&gt; <span class="code-block-s">&lt;!-- begins with xml --&gt;</span>
&lt;<span class="code-block-p">XML</span>_Car&gt; <span class="code-block-s">&lt;!-- begins with xml --&gt;</span>
&lt;C<span class="code-block-p">@</span>r&gt; <span class="code-block-s">&lt;!-- contains special character @ --&gt;</span>
&lt;my Car&gt; <span class="code-block-s">&lt;!-- contains a space --&gt;</span>
&lt;<span class="code-block-p">1</span>stCar&gt; <span class="code-block-s">&lt;!-- begins with a number --&gt;</span>
&lt;<span class="code-block-p">-</span>myCar-&gt; <span class="code-block-s">&lt;!-- although hyphens are allowed, it cannot begin with a hyphen --&gt;</span>
&lt;_my.1stXML<span class="code-block-p">:</span>Car&gt; <span class="code-block-s">&lt;!-- technically this is allowed. However, it is highly advised to avoid using colons as a name, because colons are used for namespaces, which we will cover shortly. --&gt;</span>
</code></pre>
<blockquote>
<p>Listing 13 - Incorrect naming convention examples</p>
</blockquote>
<p>As mentioned in the last comment inside Listing
13, colons (:) are allowed. However, colons are
reserved for the use of namespaces, which exist as part of the element
tag. We will cover namespaces after we have a more in-depth discussion
on attributes.</p>
<p>We have already encountered XML <em>attributes</em>.<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup> Let's
go back to our <em>CarsInStock</em> example and highlight attributes a little
more.</p>
<pre id="fence-code-95" class="fence-code"><code>1  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
2  &lt;CarsInStock&gt;
3    &lt;Car <span class="code-block-p">id="Car1"</span>&gt;
4    &lt;/Car&gt;
5    &lt;Car <span class="code-block-p">id="Car2"</span>&gt;
6    &lt;/Car&gt;
7  &lt;/CarsInStock&gt;
</code></pre>
<blockquote>
<p>Listing 14 - Highlight attributes</p>
</blockquote>
<p>Listing 14 demonstrates examples of
attributes. Attributes are contained inside an element as a name-value
pair. The value has to be in single quotes or double quotes and is
assigned to the name by an equal sign (=).</p>
<p>Let's review the following example.</p>
<pre id="fence-code-96" class="fence-code"><code>1  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
2  &lt;CarsInStock&gt;
3    &lt;Car id="Car1"&gt;
4  <span class="code-block-p">&lt;model&gt;Ford&lt;/model&gt;</span>
5    &lt;/Car&gt;
6    &lt;Car id="Car2" <span class="code-block-s">model="Toyota"</span>&gt;
7    &lt;/Car&gt;
8  &lt;/CarsInStock&gt;
</code></pre>
<blockquote>
<p>Listing 15 - Highlight attributes comparison</p>
</blockquote>
<p>Line 4 has the <em>model</em> as an element, while line 6 has it as an
attribute. There aren't any universal agreed-upon standards for the
right or wrong way, but some applications may have certain rules to
follow.</p>
<p>For cases where an application standard does not exist, some
prefer to approach this situation by inspecting the data from a
broad perspective. As we group the data into categories, we can
identify information that would more likely fit a definition of
<em>metadata</em>,<sup class="footnote-ref"><a href="#fn7" id="fnref7">7</a></sup> and create that information as attributes.</p>
<p>In other words, data that uniquely identifies other piece(s) of data
can be attributes, while more generalized data can be elements. For
example, there may be a hundred models labeled as "Ford" or "Toyota"
or other models.</p>
<p>Nonetheless, there will only be one car labeled with the id of "Car1".
This can be useful in grouping data in a meaningful way, while also
maintaining some level of uniqueness. This would further depend on
the situation, and is therefore why the idea behind using element vs
attribute is situation specific.</p>
<p>The final aspect we will demonstrate is <em>XML
namespace</em>,<sup class="footnote-ref"><a href="#fn8" id="fnref8">8</a></sup> which is used to help differentiate
between identical element names. Namespaces are beneficial when
combining multiple XML files into one.</p>
<p>Let's review the following example, which displays two separate XML
structures.</p>
<pre id="fence-code-97" class="fence-code"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;CarsInStock&gt;
  &lt;Car id="Car1"&gt;
    &lt;model&gt;Ford&lt;/model&gt;
<span class="code-block-p">&lt;color&gt;blue&lt;/color&gt;</span>
  &lt;/Car&gt;
&lt;/CarsInStock&gt;

&lt;EquipmentInStock&gt;
  &lt;Tires sn="001"&gt;
    &lt;size&gt;P225/70R1691S&lt;/Size&gt;
  &lt;/Tires&gt;
  &lt;Paint sn="002"&gt;
<span class="code-block-p">&lt;color&gt;blue&lt;/color&gt;</span>
  &lt;/Paint&gt;
&lt;/EquipmentInStock&gt;
</code></pre>
<blockquote>
<p>Listing 16 - Two separate XML data structures</p>
</blockquote>
<p>The <em>color</em> element exists twice. One refers to the color of the car,
while the other refers to the color of the paint that is available
within the <em>EquipmentInStock</em> section. This can create ambiguity.
One way to address this is to rename the element(s). For something
as simple as the above data structure, that is an easy change. What
if we had thousands of elements that had conflicting names? We could
probably automate part of that, but there is still some manual labor
involved. An easier solution is to implement namespaces within both
XML files.</p>
<p>Let's expand on the above example, but this time we will implement
namespaces.</p>
<pre id="fence-code-98" class="fence-code"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Inventory&gt;

&lt;<span class="code-block-p">veh:</span>CarsInStock <span class="code-block-p">xmlns:veh="http://schema.local/veh.xml"</span>&gt;
  &lt;<span class="code-block-p">veh:</span>Car id="Car1"&gt;
    &lt;<span class="code-block-p">veh:</span>model&gt;Ford&lt;/<span class="code-block-p">veh:</span>model&gt;
    &lt;<span class="code-block-p">veh:</span>color&gt;blue&lt;/<span class="code-block-p">veh:</span>color&gt;
  &lt;/<span class="code-block-p">veh:</span>Car&gt;
&lt;/<span class="code-block-p">veh:</span>CarsInStock&gt;

&lt;<span class="code-block-s">eq:</span>EquipmentInStock <span class="code-block-s">xmlns:eq="http://schema.local/eq.xml"</span>&gt;
  &lt;<span class="code-block-s">eq:</span>Tires sn="001"&gt;
    &lt;<span class="code-block-s">eq:</span>size&gt;P225/70R1691S&lt;/<span class="code-block-s">eq:</span>Size&gt;
  &lt;/<span class="code-block-s">eq:</span>Tires&gt;
  &lt;<span class="code-block-s">eq:</span>Paint sn="002"&gt;
    &lt;<span class="code-block-s">eq:</span>color&gt;blue&lt;/<span class="code-block-s">eq:</span>color&gt;
  &lt;/<span class="code-block-s">eq:</span>Paint&gt;
&lt;/<span class="code-block-s">eq:</span>EquipmentInStock&gt;

&lt;/Inventory&gt;
</code></pre>
<blockquote>
<p>Listing 17 - Combining two XML data structures with namespaces</p>
</blockquote>
<p>In the example above, we added a few things. First, we added a root
element named <em>Inventory</em>. We also added two <em>xlmns</em> attributes.
An xmlns attribute is an XML keyword that declares a namespace.
Highlighted in red and green, we declared two namespaces: <em>veh</em> (short
for vehicle), and <em>eq</em> (short for equipment). The values for the
namespaces are <em>Uniform Resource Identifiers</em> (URIs),<sup class="footnote-ref"><a href="#fn9" id="fnref9">9</a></sup> which
in this case point to the XML resource. These resource pointers may
or may not be used; many systems use them for documentation for that
XML structure. URIs are used in more cases beyond XML resources, like
in HTML links, UI buttons, and web pages. Lastly, highlighted in red,
we applied that same namespace name to all the elements associated
with that namespace. This includes the start and end tags of the
associated data structure.</p>
<section class="sb-block"><p>XML namespaces are not the same as Linux kernel namespaces.
The concept of a namespace means to logically group elements with a
unique identifier. The concept of a namespace is used with different
technologies.</p></section>
<p>By implementing namespaces, we can avoid element name conflicts when
we combine two or more XML structures.</p>
<p>Let's practice what we've read by doing a few exercise before moving
to learn more about JSON.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(W3, 2022), <a href="https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd" target="_blank">https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Processing_Instruction" target="_blank">https://en.wikipedia.org/wiki/Processing_Instruction</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn3"><sup>3</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/XHTML#XML_declaration" target="_blank">https://en.wikipedia.org/wiki/XHTML#XML_declaration</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn4"><sup>4</sup><p>(W3, 2022), <a href="https://www.w3.org/TR/2008/REC-xml-20081126/#sec-common-syn" target="_blank">https://www.w3.org/TR/2008/REC-xml-20081126/#sec-common-syn</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn5"><sup>5</sup><p>(W3, 2022), <a href="https://www.w3.org/TR/2008/REC-xml-20081126/#sec-comments" target="_blank">https://www.w3.org/TR/2008/REC-xml-20081126/#sec-comments</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn6"><sup>6</sup><p>(W3, 2022), <a href="https://www.w3.org/TR/2008/REC-xml-20081126/#attdecls" target="_blank">https://www.w3.org/TR/2008/REC-xml-20081126/#attdecls</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn7"><sup>7</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Metadata" target="_blank">https://en.wikipedia.org/wiki/Metadata</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn8"><sup>8</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/XML_namespace" target="_blank">https://en.wikipedia.org/wiki/XML_namespace</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn9"><sup>9</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" target="_blank">https://en.wikipedia.org/wiki/Uniform_Resource_Identifier</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>

<!----><div><h2>JSON Basics</h2>
<p>This Learning Unit covers the following Learning Objectives:</p>
<ol>
<li>Understand JSON syntax</li>
</ol>
<p>In this Learning Unit, we will learn more about <em>JavaScript Object
Notation</em> (JSON)<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> to include basic syntax.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/JSON" target="_blank">https://en.wikipedia.org/wiki/JSON</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div></section></div><!---->

<h2>JSON Introduction</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p>JSON comes from (and is sometimes used with) <em>JavaScript</em>
(JS).<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> However, many other programming languages have
libraries<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> that allow JSON implementation. Similar
to XML, JSON is standardized<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup> by the <em>Internet
Engineering Task Force</em> (IETF).<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup> JSON does have a binary
version called <em>BSON</em><sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup> or Binary JSON, which expands JSON's
utility with software like <em>MongoDB</em>.<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup> However, it is
important to note that binary data can be put into any XML and JSON
formats via encoding that binary data to hex first. The importance
behind BSON isn't pure capability, but also speed and performance.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank">https://en.wikipedia.org/wiki/JavaScript</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(JSON, 2022), <a href="https://www.json.org/json-en.html" target="_blank">https://www.json.org/json-en.html</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn3"><sup>3</sup><p>(IETF, 2022), <a href="https://datatracker.ietf.org/doc/html/rfc8259" target="_blank">https://datatracker.ietf.org/doc/html/rfc8259</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn4"><sup>4</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" target="_blank">https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn5"><sup>5</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/BSON" target="_blank">https://en.wikipedia.org/wiki/BSON</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn6"><sup>6</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/MongoDB" target="_blank">https://en.wikipedia.org/wiki/MongoDB</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>

<h2>JSON Syntax</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p>Although JSON is from JavaScript, we are not going to cover all
JavaScript syntax. We will only cover some JavaScript syntax specific
to JSON.</p>
<p>Let's check out an example.</p>
<pre id="fence-code-100" class="fence-code"><code>{"CarsInStock": 
  {"Car": [
    {"id":"Car1", "model":"Ford", "make":"Focus", "color":"Blue"},
    {"id":"Car2", "model":"Ford", "make":"F-150", "color":"Black"}
  ]}
}
</code></pre>
<blockquote>
<p>Listing 18 - JSON example</p>
</blockquote>
<p>JSON items exist in name-value pairs, where the key is a string and
the value is any JSON data type. Curly brackets ({}) signify JSON
objects, while square brackets ([]) signify arrays, and double
quotes ("") signify strings.</p>
<p>In the example above, we have a <em>CarsInStock</em> <em>object</em> that contains
another JSON object as the value. The <em>Car</em> JSON object contains an
<em>array</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> with two JSON objects. Each object within the
array contains four key-value pairs. In this instance, the values are
strings. Those strings could be serialized hex or base64, which could
contain any data type or structure. Other JSON data types that we
could use are numbers and Booleans.</p>
<p>Here is an example of JSON with serialized base64 data inside it. We
will start by manually generating a base64 string. In the example,
we have a file called <strong>privatekeyP384.pem</strong>, which is a private
key generated from <strong>openssl</strong> in PEM-encoded<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> format. We
will then use an <strong>openssl</strong> command to extract the public key from
the private key and print it out to the terminal, redirecting STDERR
output to <strong>/dev/null</strong> as we do not want to include that in our
encoded data. Then we will extract the same public key but this time,
pipe the public key output to <strong>base64</strong> to encode it and then to
<strong>tr</strong> to remove the line breaks to serialize it for our JSON string.</p>
<pre id="fence-code-101" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">openssl ecparam -name secp384r1 -genkey -noout -out privatekeyP384.pem</span>

kali@kali:~$ <span class="code-block-ui">openssl ec -in privatekeyP384.pem -pubout 2&gt;/dev/null</span>
-----BEGIN PUBLIC KEY-----
MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE+beLyPkbrMiPSNhk3yfcsEQdgZHa7c60
+r7W59103Fah8QeSRXI2Ju6y3b+I9SNX/2aoQF95E7w9XkYogzsd8qtVxY08iSzM
4RWos0b2f2YI+fv5BxTtuhKbt3OEuNMQ
-----END PUBLIC KEY-----

kali@kali:~$ <span class="code-block-ui">openssl ec -in privatekeyP384.pem -pubout 2&gt;/dev/null | base64  | tr -d '\n'</span>
<span class="code-block-p">LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUhZd0VBWUhLb1pJemowQ0FRWUZLNEVFQUNJRFlnQUUrYmVMeVBrYnJNaVBTTmhrM3lmY3NFUWRnWkhhN2M2MAorcjdXNTkxMDNGYWg4UWVTUlhJMkp1NnkzYitJOVNOWC8yYW9RRjk1RTd3OVhrWW9nenNkOHF0VnhZMDhpU3pNCjRSV29zMGIyZjJZSStmdjVCeFR0dWhLYnQzT0V1Tk1RCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo=</span>

</code></pre>
<blockquote>
<p>Listing 19 - base64 encoding a PEM for a JSON string</p>
</blockquote>
<p>Notice how openssl outputs base64 encoded data as well, and then
we are taking the special PEM encoding and encoding it again as
serialized base64. Next we can further encode it in JSON.</p>
<pre id="fence-code-102" class="fence-code"><code>{"example-public-key-b64-p384-pem":"LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUhZd0VBWUhLb1pJemowQ0FRWUZLNEVFQUNJRFlnQUUrYmVMeVBrYnJNaVBTTmhrM3lmY3NFUWRnWkhhN2M2MAorcjdXNTkxMDNGYWg4UWVTUlhJMkp1NnkzYitJOVNOWC8yYW9RRjk1RTd3OVhrWW9nenNkOHF0VnhZMDhpU3pNCjRSV29zMGIyZjJZSStmdjVCeFR0dWhLYnQzT0V1Tk1RCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo="}
</code></pre>
<blockquote>
<p>Listing 20 - base64 in JSON</p>
</blockquote>
<p>With the example public key now in JSON, we might be able to store it,
and know what the data is, be able to load it and use it in multiple
systems. While the PEM format is also a serialization format
that many different applications can use directly, the PEM format is
not valid JSON.</p>
<p>We needed to do serialized base64 (or hex) to fit that data into
the JSON format in this case. If we tried to insert PEM directly
into JSON, we have invalid JSON. To avoid that problem, we used the
serialized base64 encoding of the PEM-encoded cryptographic component.</p>
<pre id="fence-code-103" class="fence-code"><code>{
  "example-public-key": "-----BEGIN PUBLIC KEY-----
MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE+beLyPkbrMiPSNhk3yfcsEQdgZHa7c60
+r7W59103Fah8QeSRXI2Ju6y3b+I9SNX/2aoQF95E7w9XkYogzsd8qtVxY08iSzM
4RWos0b2f2YI+fv5BxTtuhKbt3OEuNMQ
-----END PUBLIC KEY-----
"
}
</code></pre>
<blockquote>
<p>Listing 21 - invalid JSON example</p>
</blockquote>
<p>JSON has a multiple specifications, including JSON-LD and JSON
Pointer, but we are discussing the JSON spec for JavaScript Object
Notation. In this specification, JSON must use either UTF-32,
UTF-16, or UTF-8 characters. But not all Unicode characters will work
correctly in JSON unless they are either escaped or further encoded
(to hex or web-safe base64).</p>
<p>Ideally, the strings in JSON only contain alpha-numeric characters,
although many other characters can work or be escaped with an escape
sequence. The different types of escape sequences are demonstrated
here.</p>
<pre id="fence-code-104" class="fence-code"><code>    \\ back slash escape (reverse solidus escape)
    \" doublequote escape
    \/ forward slash escape (solidus escape)
    \b backspace escape
    \f formfeed escape
    \n newline escape
    \r return escape
    \t tab escape
</code></pre>
<blockquote>
<p>Listing 22 - JSON escape sequences</p>
</blockquote>
<p>The JSON key names may use the hyphen (-) and the underscore (_),
as well as spaces. The hyphen and other special characters in example
data are invalid in JSON strings. This is why we encode such data to
serialized web-safe base64 or hex first.</p>
<section class="sb-block"><p>We are pointing out this technique of putting data that doesn't
otherwise fit in the serialization language format inside serialized
hex or base64, because the concept is used heavily in the industry,
and often used specifically with sensitive and interesting data.</p></section>
<p>Many instances of data are well within the alpha-numeric range and
work well as normal text. Data that is outside of the alpha-numeric
data we like for strings, but may want to serialize, is commonly
binary blobs (raw data). While we may not be able to "read" the blobs
directly because there are no inherent characters to represent them,
we can encode the blob into hex or base64, and decode it just as
easily.</p>
<p>Even though we have to meet the requirements while the JSON is
being treated as JSON, that doesn't mean the data has to always
stay as JSON. The way it is stored on disk can be separate from the
serialization language format, typically as long as the serialized
form is able to be restored before transport or loading. Common
examples are to compress then encrypt. To explain this section, we
will have a JSON document <em>gzipped</em><sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>. Any file or data can go through
GNU zip compression, with the goal of making the data smaller.</p>
<p>Using the public key example JSON, we can store that in a file called
<strong>example-pub.json</strong>, then use the <em>gzip</em> program to compress it. We
will pass the <strong>-9</strong> option to <strong>gzip</strong> to use maximum gzip algorithm
compression. We will use <strong>du</strong> with the <strong>-b</strong> option to measure the
bytes in the file before and after the compression is applied.</p>
<pre id="fence-code-105" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">du -b example-pub.json</span>
327

kali@kali:~$ <span class="code-block-ui">cat example-pub.json</span>
{"example-public-key-b64-p384-pem":"LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUhZd0VBWUhLb1pJemowQ0FRWUZLNEVFQUNJRFlnQUUrYmVMeVBrYnJNaVBTTmhrM3lmY3NFUWRnWkhhN2M2MAorcjdXNTkxMDNGYWg4UWVTUlhJMkp1NnkzYitJOVNOWC8yYW9RRjk1RTd3OVhrWW9nenNkOHF0VnhZMDhpU3pNCjRSV29zMGIyZjJZSStmdjVCeFR0dWhLYnQzT0V1Tk1RCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo="}

kali@kali:~$ <span class="code-block-ui">ls</span>
example-pub.json

kali@kali:~$ <span class="code-block-ui">gzip -9 example-pub.json</span>

kali@kali:~$ <span class="code-block-ui">ls</span>
example-pub.json.gz

kali@kali:~$ <span class="code-block-ui">du -b example-pub.json.gz</span>
308

kali@kali:~$ <span class="code-block-ui">cat example-pub.json.gz</span>
...(data can't be displayed properly)...

kali@kali:~$ <span class="code-block-ui">gunzip example-pub.json.gz</span>

</code></pre>
<blockquote>
<p>Listing 23 - compressed JSON example</p>
</blockquote>
<p>This cryptographic component went though a number of transformations
in these examples. Originally, openssl output the data as PEM encoded.
Then we encoded the PEM to serialized base64, then inserted that
serialized base64 into JSON, then finally compressed the JSON file.
This is an example of how data might be put behind layers of encoding
and serialization, and how transformations might be applied to data.</p>
<p>It may seem strange to have so many layers, but the reality of modern
applications is that binary data does commonly go through layers
of encoding like our example. We don't need to worry too much about
understanding PEM and the public key for this module, but we do
want to start practicing decoding, decompressing, decrypting, and
deserializing data.</p>
<p>In addition to manipulating JSON files, we can also manipulate JSON
within the web browser using JavaScript. Next we will use a web
browser console to explore JSON further. To follow along, we can open
a web browser on any website, hit the F12 key, select <em>Console</em>, and
enter our JavaScript there.</p>
<p>We can use <em>JSON.parse()</em> to import JSON into JavaScript and assign it
to a variable named <em>myCar</em>.</p>
<pre id="fence-code-106" class="fence-code"><code>var myCar = JSON.parse('{"id":"Car1", "model":"Ford", "make":"Focus", "color":"Blue"}');
</code></pre>
<blockquote>
<p>Listing 24 - JSON.parse() function example</p>
</blockquote>
<p>Now we can display the data or manipulate it further. Let's use
<em>console.log()</em> to output JSON data.</p>
<pre id="fence-code-107" class="fence-code has-commands"><code><span class="code-block-ui">console.log(myCar);</span>

<span class="code-block-p">{
  id: "Car1",
  model: "Ford",
  make: "Focus",
  color: "Blue"
}</span>
</code></pre>
<blockquote>
<p>Listing 25 - Use console.log() function</p>
</blockquote>
<p>To reverse the process, we use the <em>JSON.stringify()</em> function. Let's do
that, then use <em>console.log()</em> to output the the data.</p>
<pre id="fence-code-108" class="fence-code has-commands"><code><span class="code-block-ui">var myCarStringify = JSON.stringify(myCar);
console.log(myCarStringify);</span>

<span class="code-block-p">{"id":"Car1","model":"Ford","make":"Focus","color":"Blue"}</span>
</code></pre>
<blockquote>
<p>Listing 26 - Use console.log() function to output myCarStringify</p>
</blockquote>
<p>Now that we have a better understanding of interacting with JSON,
let's practice the concepts with the following exercises.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Mozilla, 2022), <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(IETF, 2015), <a href="https://www.rfc-editor.org/rfc/rfc7468" target="_blank">https://www.rfc-editor.org/rfc/rfc7468</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn3"><sup>3</sup><p>(GNU.org), <a href="https://www.gnu.org/software/gzip/" target="_blank">https://www.gnu.org/software/gzip/</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>

<!----><div><h2>YAML Basics</h2>
<p>This Learning Unit covers the following Learning Objectives:</p>
<ol>
<li>Understand basic YAML syntax</li>
<li>Create YAML configuration files</li>
</ol>
<p>In this Learning Unit, we will learn more about <em>YAML Ain't Markup
Language</em> (YAML)<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> to include basic syntax.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/YAML" target="_blank">https://en.wikipedia.org/wiki/YAML</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div></section></div><!---->

<h2>YAML Introduction</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p>YAML was created during a time when many other markup languages
were released. The acronym initially stood for <em>Yet Another Markup
Language</em>. However, its purpose shifted from a document markup
language to become more data-oriented, making it a flexible data
serialization language.</p>
<p>Eventually, changing its name into a <em>recursive
acronym</em>,<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> "YAML Ain't Markup Language", meaning
the acronym refers to itself. Although it can be used in place of data
serialization languages such as JSON in some cases, YAML is popularly
used as configuration files for configuration management tools. For
example, <em>Red Hat's Ansible Playbooks</em><sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> are created using
YAML files, which are used to run tasks on multiple computer systems.</p>
<p>YAML allows all printable Unicode characters within it, including
control characters (excluding the tab character). YAML also allows the
surrogate character block.<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup></p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Recursive_acronym" target="_blank">https://en.wikipedia.org/wiki/Recursive_acronym</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(Ansible, 2022), <a href="https://www.ansible.com/" target="_blank">https://www.ansible.com/</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn3"><sup>3</sup><p>(datacadamia.com), <a href="https://datacadamia.com/data/type/text/surrogate" target="_blank">https://datacadamia.com/data/type/text/surrogate</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>

<h2>YAML Syntax</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p><em>YAML</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup><sup>,</sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> is complex, especially when it is
applied to other applications that require additional rules. In this
section, we will get a very basic understanding of the syntax.</p>
<p>One of the most important syntax rules to remember is that, unlike
XML and JSON, YAML has strict whitespace indentation rules in some
of the specification. Proper parsing of common YAML block structures
will not occur if spaces are not implemented correctly. Although YAML
documentation defines usage of space, it does <em>not</em> dictate a standard
number of spaces to use. In other words, we can decide the number of
spaces ourselves to some degree. Generally we will want to use two or
four spaces. For this module, we will use two spaces per indentation.</p>
<p>Although not always a requirement, YAML documents begin with three
hyphens (---) and end with three periods (...). The beginning and
ending sequences are most commonly used when YAML is processed as
a stream of multiple YAML files or when YAML files are concatenated
together. We can consider it a best practice to include them.</p>
<pre id="fence-code-111" class="fence-code"><code>---
...
</code></pre>
<blockquote>
<p>Listing 27 - Beginning and ending of YAML document</p>
</blockquote>
<p>Comments are represented by a pound sign (#).</p>
<pre id="fence-code-112" class="fence-code"><code>---
<span class="code-block-p">#</span> My comment
...
</code></pre>
<blockquote>
<p>Listing 28 - YAML comment</p>
</blockquote>
<p>There are many types of characters and data structures allowed in YAML
(many more than XML and JSON allow). We can use a single key-value
pair by itself or if we want to, we can also include multiple complex
data structures.</p>
<p>Let's review an example of a single key-value pair with a comment.</p>
<pre id="fence-code-113" class="fence-code"><code>---
# Cars In Stock
<span class="code-block-p">key: value</span>
...
</code></pre>
<blockquote>
<p>Listing 29 - YAML key-value pair example</p>
</blockquote>
<p>YAML has many different data types and styles available to it. In
YAML we have <em>nodes</em>, and each node can have a different <em>node style</em>.
There are two primary types of node styles: <em>block</em> and <em>flow</em>. The
overly simplified explanation of the difference is that block style
uses the spaces indentation as delimiters while flow styles use
explicit character delimiters.</p>
<p>In our example YAML, the node is <em>Cars In Stock</em>, and the node style
is block style, as the indentation is used to delimit the values.</p>
<pre id="fence-code-114" class="fence-code"><code>---
Cars In Stock:
  Car 1:
    model: Ford
    type: domestic
  Car 2:
    model: Ford
    type: domestic
  Car 3:
    model: Toyota
    type: foreign
  Car 4:
    model: Toyota
    type: foreign
...
</code></pre>
<blockquote>
<p>Listing 30 - YAML block style</p>
</blockquote>
<p>In the example above, we have one YAML node containing nodes, each
containing two key-value pairs.</p>
<p>The <em>canonical YAML</em> representation of the same data is much more
verbose, with labels for each aspect. Rarely will we write out
canonical YAML manually, but it is good to be aware of.</p>
<pre id="fence-code-115" class="fence-code"><code>---
!!map {
  ? !!str "Cars In Stock"
  : !!map {
    ? !!str "Car 1"
    : !!map {
      ? !!str "model"
      : !!str "Ford",
      ? !!str "type"
      : !!str "domestic",
    },
    ? !!str "Car 2"
    : !!map {
      ? !!str "model"
      : !!str "Ford",
      ? !!str "type"
      : !!str "domestic",
    },
    ? !!str "Car 3"
    : !!map {
      ? !!str "model"
      : !!str "Toyota",
      ? !!str "type"
      : !!str "foreign",
    },
    ? !!str "Car 4"
    : !!map {
      ? !!str "model"
      : !!str "Toyota",
      ? !!str "type"
      : !!str "foreign",
    },
  },
}
</code></pre>
<blockquote>
<p>Listing 31 - YAML canonical example</p>
</blockquote>
<p>Next we will change the data slightly to demonstrate how YAML can
include different formats within different YAML nodes.</p>
<pre id="fence-code-116" class="fence-code"><code>---
Cars In Stock:
  Car 1:
    - model: Ford
    - type: domestic
  Car 2:
    - "model Ford"
    - "type domestic"
  Car 3:
    model: Toyota
    type: foreign
  Car 4:
    model: Toyota
    type: foreign
...
</code></pre>
<blockquote>
<p>Listing 32 - YAML style examples</p>
</blockquote>
<p>With the latest variation of the data, <em>Car 1</em> uses the hyphen block
style delimiter. We have significantly changed the data in <em>Car 2</em> to
also use hyphen block style delimiters, but also using strings instead
of key-value pairs.</p>
<p>Let's break down the indication characters in YAML a little further.</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>YAML use</th>
</tr>
</thead>
<tbody>
<tr>
<td>hyphen</td>
<td>block sequence</td>
</tr>
<tr>
<td>question mark</td>
<td>mapping key</td>
</tr>
<tr>
<td>colon</td>
<td>mapping value</td>
</tr>
<tr>
<td>comma</td>
<td>flow collection entry</td>
</tr>
<tr>
<td>square bracket</td>
<td>flow sequence</td>
</tr>
<tr>
<td>curly braces</td>
<td>flow mapping</td>
</tr>
<tr>
<td>pound sign</td>
<td>comment</td>
</tr>
<tr>
<td>ampersand</td>
<td>node anchor</td>
</tr>
<tr>
<td>asterix</td>
<td>alias node</td>
</tr>
<tr>
<td>exclamation mark</td>
<td>node tag</td>
</tr>
<tr>
<td>vertical bar</td>
<td>literal block scalar</td>
</tr>
<tr>
<td>greater than sign</td>
<td>folded block scalar</td>
</tr>
<tr>
<td>single quotes</td>
<td>flow scalars</td>
</tr>
<tr>
<td>double quotes</td>
<td>flow scalars</td>
</tr>
<tr>
<td>percent sign</td>
<td>directive</td>
</tr>
<tr>
<td>at-sign</td>
<td>reserved for future</td>
</tr>
<tr>
<td>back-tick</td>
<td>reserved for future</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Table 3 - YAML indicators</p>
</blockquote>
<p>The flow indicators might seem familiar as JSON uses them. We can
consider flow style of YAML to be an extension of JSON. All JSON can
be used in YAML but not all YAML is valid JSON.</p>
<p>Now that we have a better understanding of the basic YAML syntax,
let's inspect a few examples of how YAML can be used.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Yaml, 2022), <a href="https://yaml.org/" target="_blank">https://yaml.org/</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(yaml.org, 2021), <a href="https://yaml.org/spec/1.2.2/" target="_blank">https://yaml.org/spec/1.2.2/</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>

<h2>YAML Files</h2>

<div class="markdown-content text-main-color flex-grow my-6 mx-auto"><!----><div><p>Now that we have a good understanding of the structure of YAML,
let's review a generic example. It's important to verify syntax
and while we can manually validate a file for proper syntax, an
automated method is much quicker. We can use a validator for many data
serialization languages, but our focus is primarily on validating YAML
files. <em>Parsing</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> can have different meanings, but for
this purpose, it refers to analyzing code to ensure certain syntactic
rules (proper spacing, for example) are followed. If we have syntax
errors, validating can help identify them quicker.</p>
<p>Let's walk through an example. To follow along, it is best to
use the in-browser Kali. We <em>are</em> able to perform the following
steps using a local machine, but it may require additional
steps to set up the environment (primarily, installing <em>PyYAML</em>
<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup><sup>,</sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>).</p>
<p>Let's imagine we are responsible for hardware inventory, which
includes maintaining a YAML file with equipment information. This is a
requirement because the software consumers use to view and query what
we have in stock requires us to use a YAML format. For this example,
there are no additional application YAML rules. Let's organize the
following information so that it is valid YAML.</p>
<table>
<thead>
<tr>
<th>Count</th>
<th>Item descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>Dell monitors (24in, 24in, 27in, 32in); no 40in monitors</td>
</tr>
<tr>
<td>1</td>
<td>HP monitor (24in)</td>
</tr>
<tr>
<td>3</td>
<td>Logitech keyboards (2 wired, 1 wireless)</td>
</tr>
<tr>
<td>10</td>
<td>USB to HDMI adapter cables (five 1 meter, five 2 meters)</td>
</tr>
<tr>
<td>6</td>
<td>DisplayPort to HDMI adapter cables (four 1 meter, two 2 meters)</td>
</tr>
<tr>
<td>1</td>
<td>HP printer (color with scanning)</td>
</tr>
<tr>
<td>0</td>
<td>desktops</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Table 4 - example inventory data</p>
</blockquote>
<p>One way to organize this is by equipment type. This method may
make sense for employees who need specific equipment, such as a
monitor or keyboard. Some companies may have business contracts with
manufacturers, like Dell, or business requirements, such as monthly
inventory and lease date reports, so we may want to organize items
by brand first, then equipment type. For a small business with even
less equipment, our concern might be to organize items by a unique
identifier, such as a serial number. In that case, we can have the
unique ID for each YAML node, followed by the rest of the information
for the equipment.</p>
<p>As mentioned previously, there are many ways to organize raw data.
Various factors need to be taken into consideration, and we should
be open to change in case our first solution doesn't quite fit the
problem.</p>
<p>Let's review one method of organizing the inventory list in this
example.</p>
<pre id="fence-code-117" class="fence-code"><code>---
# Items in stock
monitors:
  - brand: Dell
    size:
      24: 2
      27: 1
      32: 1
      40: 0
  - brand: HP
    size:
      24: 1
keyboards:
  - brand: Logitech
    type:
      wired: 2
      wireless: 1
cables:
  - type:
    - USB_to_HDMI:
      - length:
          1m: 5
          2m: 5
    - DisplayPort_to_HDMI:
      - length:
          1m: 4
          2m: 2
printers:
  - serialNum123:
      - HP
      - color
      - scanning
desktops:
...
</code></pre>
<blockquote>
<p>Listing 33 - Example yaml given our inventory information</p>
</blockquote>
<p>Let's take the YAML code from Listing 33 and
place it in a file called <strong>inventory.yaml</strong>.</p>
<p>Next, we will use the PyYAML Python module to create a validation
script that will parse YAML files and validate them.</p>
<p>In the same directory, we'll create a file called <strong>validation.py</strong>.</p>
<pre id="fence-code-118" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">pwd</span>
<span class="code-block-p">/home/kali/Desktop</span>

kali@kali:~$ <span class="code-block-ui">ls</span>
<span class="code-block-p">inventory.yaml  validation.py</span>
</code></pre>
<blockquote>
<p>Listing 34 - Two files located in the same directory</p>
</blockquote>
<p>In <strong>validation.py</strong>, we'll use the following code:</p>
<pre id="fence-code-119" class="fence-code"><code>#!/usr/bin/env python
import yaml

with open("inventory.yaml", "r") as f:
  yaml.safe_load(f)
</code></pre>
<blockquote>
<p>Listing 35 - Displaying contents of validation.py</p>
</blockquote>
<p>On the first line, we <strong>import yaml</strong>. Then, using <strong>open</strong>, we read
(<strong>r</strong> ) <strong>inventory.yaml</strong> and use the contents as the argument for
the <em>safe_load()</em> function. This function takes in a stream, parses
it, and outputs the data or an error message.</p>
<p>If there are errors, it will output them. In this case, because we are
not printing the output of the function, nothing will happen if our
YAML file is error-free.</p>
<pre id="fence-code-120" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">python3 validation.py</span>

kali@kali:~$
</code></pre>
<blockquote>
<p>Listing 36 - Running validation.py</p>
</blockquote>
<p>As expected, our YAML file is free of errors so we don't have any
output.</p>
<p>Let's intentionally remove the colon in line 4, after the word
"monitors", and run the script again.</p>
<pre id="fence-code-121" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">python3 validation.py</span>
Traceback (most recent call last):
  File "/home/kali/Desktop/validation.py", line 4, in &lt;module&gt;
    yaml.safe_load(f)
  File "/usr/lib/python3/dist-packages/yaml/__init__.py", line 162, in safe_load
    return load(stream, SafeLoader)
  File "/usr/lib/python3/dist-packages/yaml/__init__.py", line 114, in load
    return loader.get_single_data()
  File "/usr/lib/python3/dist-packages/yaml/constructor.py", line 49, in get_single_data
    node = self.get_single_node()
  File "/usr/lib/python3/dist-packages/yaml/composer.py", line 36, in get_single_node
    document = self.compose_document()
  File "/usr/lib/python3/dist-packages/yaml/composer.py", line 55, in compose_document
    node = self.compose_node(None, None)
  File "/usr/lib/python3/dist-packages/yaml/composer.py", line 82, in compose_node
    node = self.compose_sequence_node(anchor)
  File "/usr/lib/python3/dist-packages/yaml/composer.py", line 110, in compose_sequence_node
    while not self.check_event(SequenceEndEvent):
  File "/usr/lib/python3/dist-packages/yaml/parser.py", line 98, in check_event
    self.current_event = self.state()
  File "/usr/lib/python3/dist-packages/yaml/parser.py", line 382, in parse_block_sequence_entry
    if self.check_token(BlockEntryToken):
  File "/usr/lib/python3/dist-packages/yaml/scanner.py", line 116, in check_token
    self.fetch_more_tokens()
  File "/usr/lib/python3/dist-packages/yaml/scanner.py", line 223, in fetch_more_tokens
    return self.fetch_value()
  File "/usr/lib/python3/dist-packages/yaml/scanner.py", line 577, in fetch_value
    raise ScannerError(None, None,
<span class="code-block-p">yaml.scanner.ScannerError: mapping values are not allowed here
  in "inventory.yaml", line 5, column 12</span>
</code></pre>
<blockquote>
<p>Listing 37 - Displaying error message</p>
</blockquote>
<p>All we care about is the last portion of the error message. In this
case, we want to remove the unnecessary error messages.</p>
<p>Let's adjust our validation script a little bit to clean up our
output.</p>
<p>The Python script should resemble this:</p>
<pre id="fence-code-122" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">cat validation.py</span>
#!/usr/bin/env python
import yaml

with open("inventory.yaml", "r") as f:
    <span class="code-block-p">try:
        print(yaml.safe_load(f))
    except yaml.YAMLError as error:
        print(error)</span>
</code></pre>
<blockquote>
<p>Listing 38 - Displaying contents of updated validation.py</p>
</blockquote>
<p>We added a <em>try</em> and an <em>except</em> block of code. First, it tries to run
the <em>safe_load()</em> function and this time it prints out the data. In
any other case, it will print out the error.</p>
<p>Let's run the Python script again.</p>
<pre id="fence-code-123" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">python3 validation.py</span>
<span class="code-block-p">mapping values are not allowed here
  in "inventory.yaml", line 5, column 12</span>
</code></pre>
<blockquote>
<p>Listing 39 - Displaying updated error message</p>
</blockquote>
<p>This time, we get a much cleaner error message. This way, we can
quickly focus on identifying what we need to fix. In this case, it
informs us that we created mapping values on line 5 that are not
allowed. This is because we are missing the colon on line 4. Let's go
ahead and re-add the colon and run the script again.</p>
<pre id="fence-code-124" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">python3 validation.py</span>
<span class="code-block-p">{'monitors': [{'brand': 'Dell', 'size': {24: 2, 27: 1, 32: 1, 40: 0}}, {'brand': 'HP', 'size': {24: 1}}], 'keyboards': [{'brand': 'Logitech', 'type': {'wired': 2, 'wireless': 1}}], 'cables': [{'type': [{'USB_to_HDMI': [{'length': {'1m': 5, '2m': 5}}]}, {'DisplayPort_to_HDMI': [{'length': {'1m': 4, '2m': 2}}]}]}], 'printers': [{'serialNum123': ['HP', 'color', 'scanning']}], 'desktops': None}</span>
</code></pre>
<blockquote>
<p>Listing 40 - Printing YAML data</p>
</blockquote>
<p>As expected, because our YAML file did not have any errors, the
contents are printed.</p>
<p>This validation can be conducted using different programming languages
and it can validate various serialization language formats. This is
just one example of how we can validate formats.</p>
<p>Next, we will analyze a more realistic example of how YAML is
used. The important note to remember here is that applications can
have additional specific constraints. For example, YAML general
specifications versus YAML used in <em>Ansible</em><sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup> versus
YAML used in <em>Kubernetes</em><sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup> are not the same. There are
similarities, but due to specific applications, general YAML may not
be valid when applied to an Ansible YAML specification.</p>
<p>The purpose of this section is not to become proficient with how to
use the specific application or configuration management tool, but
instead, learn how YAML can be used in a real world scenario.</p>
<p>Let's review an example of a YAML configuration file used in Ansible.</p>
<pre id="fence-code-125" class="fence-code"><code>---
- hosts: "web servers"
  name: "disable ssh"
  tasks: 
    - lineinfile: "dest=/etc/ssh/sshd_config regexp =\"^PermitRootLogin\" line=\"PermitRootLogin no\" state=present"
      name: "disable root ssh login"
      notify: 
        - "restart sshd"
  user: root
...
</code></pre>
<blockquote>
<p>Listing 41 - Example YAML configuration file for Ansible</p>
</blockquote>
<p>The specifics of what Ansible does with the above code is out of
scope, so our focus is more on showcasing YAML syntax. Let's validate
this YAML code using our script.</p>
<pre id="fence-code-126" class="fence-code has-commands"><code>kali@kali:~$ <span class="code-block-ui">python3 validation.py</span>
<span class="code-block-p">[{'hosts': 'web servers', 'name': 'disable ssh', 'tasks': [{'lineinfile': 'dest=/etc/ssh/sshd_config regexp ="^PermitRootLogin" line="PermitRootLogin no" state=present', 'name': 'disable root ssh login', 'notify': ['restart sshd']}], 'user': 'root'}]</span>
</code></pre>
<blockquote>
<p>Listing 42 - Running Ansible YAML code through the validation.py script</p>
</blockquote>
<p>Remember, this script only checks generic YAML syntax. Our
purpose is to outline the method of validating data serialization
code, such as JSON and YAML. For an application-specific
situation, like Ansible, we would need to run the file through an
Ansible-specific validator that not only checks for generic YAML
syntax, but also Ansible-specific YAML syntax. We can take this even
further and create our own schema that checks for user-created rules.
Understanding this is out of scope, but the takeaway is knowing that
there is a distinction between generic YAML and specific application
YAML.</p>
<p>Using YAML, we created an example configuration file that we can use
with Ansible. Ansible has specific keywords to use as the "key" value
in a key-value pair. Once we understand what each key's function
is, we can create the YAML file to work with Ansible. This same
idea can be applied to similar use cases or with other configuration
management tools. The major difference would be understanding
the application-specific rules and how they apply to the data
serialization language.</p>
<section class="footnote-container"><div class="footnote-item" id="fn1"><sup>1</sup><p>(Wikipedia, 2022), <a href="https://en.wikipedia.org/wiki/Parsing" target="_blank">https://en.wikipedia.org/wiki/Parsing</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn2"><sup>2</sup><p>(PyYAML, 2022), <a href="https://pyyaml.org/wiki/PyYAML" target="_blank">https://pyyaml.org/wiki/PyYAML</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn3"><sup>3</sup><p>(PyPi, 2022), <a href="https://pypi.org/project/PyYAML/" target="_blank">https://pypi.org/project/PyYAML/</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn4"><sup>4</sup><p>(Ansible, 2022), <a href="https://www.ansible.com/" target="_blank">https://www.ansible.com/</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</div><div class="footnote-item" id="fn5"><sup>5</sup><p>(Kubernetes, 2022), <a href="https://kubernetes.io/" target="_blank">https://kubernetes.io/</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</div></section></div><!----></div>